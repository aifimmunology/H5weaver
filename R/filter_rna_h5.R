#' Add cell IDs to a h5_list object
#'
#' @param h5_list a list object generated by running rhdf5::h5dump() on a 10x HDF5 file.
#' @param add_uuid a logical indicating whether or not to add a uuid generated by ids::uuid(). Default is TRUE.
#' @param replace_barcode a logical indicating whether or not the new uuid should replace the barcodes slot. Default is TRUE.
#' @param retain_original_barcode a logical indicating whether to retain the original barcodes if replace_barcode is TRUE. These will be moved to /matrix/original_barcode if TRUE. Default is TRUE.
#' @param add_name a logical indicating whether to add a new cell name. These are adjective_adjective_animal names generated by ids::adjective_animal(). Default is TRUE.
#'
#' @return a modified h5_list object
#' @export
#'
add_cell_ids <- function(h5_list,
                         add_uuid = TRUE,
                         replace_barcode = TRUE,
                         retain_original_barcode = TRUE,
                         add_name = TRUE) {

  assertthat::assert_that(class(h5_list) == "list")
  assertthat::assert_that("matrix" %in% names(h5_list))

  assertthat::assert_that(is.logical(add_uuid))
  assertthat::assert_that(is.logical(add_name))

  if(add_uuid || add_name) {
    if(!"observations" %in% names(h5_list$matrix)) {
      h5_list$matrix$observations <- list()
    }
  }

  if(add_uuid) {

    if(replace_barcode) {
      if(retain_original_barcode) {
        h5_list$matrix$observations$original_barcodes <- h5_list$matrix$barcode
      }
      # matrix$barcodes is used for column ids by most functions that read 10x HDF5 files.
      h5_list$matrix$barcodes <- ids::uuid(n = length(h5_list$matrix$barcodes),
                                           drop_hyphens = TRUE,
                                           use_time = TRUE)
    }

    h5_list$matrix$observations$cell_uuid <- ids::uuid(n = length(h5_list$matrix$barcodes),
                                                       drop_hyphens = TRUE,
                                                       use_time = TRUE)
  }

  if(add_name) {
    h5_list$matrix$observations$cell_name <- ids::adjective_animal(n = length(h5_list$matrix$barcodes),
                                                                   n_adjectives = 2,
                                                                   max_len = 10)
  }

  h5_list

}

#' Convert the matrix in an h5_list from 10x Genomics data to a sparse matrix
#'
#' This is very useful for subsetting the matrix based on column names.
#'
#' @param h5_list a list object generated by running rhdf5::h5dump() on a 10x HDF5 file.
#' @param target the group name for the sparse matrix. Default is "matrix", which is used by 10x.
#'
#' @return a list object
#' @export
#'
h5_list_convert_to_dgCMatrix <- function(h5_list,
                                         target = "matrix") {

  assertthat::assert_that(class(h5_list) == "list")
  assertthat::assert_that(target %in% names(h5_list))
  target_dgCMatrix <- paste0(target,"_dgCMatrix")

  h5_list[[target_dgCMatrix]] <- Matrix::sparseMatrix(x = h5_list[[target]]$data,
                                                      i = h5_list[[target]]$indices,
                                                      index1 = FALSE,
                                                      p = h5_list[[target]]$indptr,
                                                      dims = h5_list[[target]]$shape,
                                                      dimnames = list(h5_list[[target]]$features$id,
                                                                      h5_list[[target]]$barcodes))
  h5_list[[target]]$data <- NULL
  h5_list[[target]]$indices <- NULL
  h5_list[[target]]$indptr <- NULL
  h5_list[[target]]$shape <- NULL
  h5_list[[target]]$features$id <- NULL
  h5_list[[target]]$barcodes <- NULL

  h5_list
}

#' Convert the matrix in an h5_list from a sparse matrix back to its original structure
#'
#' This is very useful for preparing to write back out to an .h5 file.
#'
#' @param h5_list a list object generated by running rhdf5::h5dump() on a 10x HDF5 file, with a matrix converted by h5_list_convert_to_dgCMatrix().
#' @param target the group name of the original sparse matrix. Default is "matrix", which is used by 10x.
#'
#' @return a list object
#' @export
#'
h5_list_convert_from_dgCMatrix <- function(h5_list,
                                           target = "matrix") {

  assertthat::assert_that(class(h5_list) == "list")

  target_dgCMatrix <- paste0(target,"_dgCMatrix")
  assertthat::assert_that(target_dgCMatrix %in% names(h5_list))

  h5_list[[target]]$data <- h5_list[[target_dgCMatrix]]@x
  h5_list[[target]]$indices <- h5_list[[target_dgCMatrix]]@i
  h5_list[[target]]$indptr <- h5_list[[target_dgCMatrix]]@p
  h5_list[[target]]$shape <- dim(h5_list[[target_dgCMatrix]])
  h5_list[[target]]$barcodes <- colnames(h5_list[[target_dgCMatrix]])
  h5_list[[target]]$features$id <- rownames(h5_list[[target_dgCMatrix]])

  h5_list[[target_dgCMatrix]] <- NULL

  h5_list
}

#' Add a sparse matrix to an h5_list containing 10x genomics data
#'
#' @param h5_list a list object, usually generated by running rhdf5::h5dump() on a 10x HDF5 file.
#' @param mat a dgCMatrix to add to the h5_list
#' @param target a character object specifying the location within the list to write to.
#'
#' @return a list object with the additional matrix added similar to 10x HDF5 matrix format.
#' @export
#'
h5_list_add_dgCMatrix <- function(h5_list,
                                  mat,
                                  target) {

  assertthat::assert_that(class(h5_list) == "list")
  assertthat::assert_that(class(mat) == "dgCMatrix")

  h5_list[[target]]$data <- mat@x
  h5_list[[target]]$indices <- mat@i
  h5_list[[target]]$indptr <- mat@p
  h5_list[[target]]$shape <- dim(mat)
  h5_list[[target]]$barcodes <- colnames(mat)
  h5_list[[target]]$features <- list(id = rownames(mat))

  h5_list
}


#' Subset a h5_list object based on a set of barcodes.
#'
#' @param h5_list a list object generated by running rhdf5::h5dump() on a 10x HDF5 file, with a matrix converted by h5_list_convert_to_dgCMatrix().
#' @param barcodes a set of barcodes to select for filtering
#' @param original_barcodes a logical indicating if the original_barcodes object should be used instead of barcodes (in case uuids have replaced original barcodes)
#'
#' @return a list object
#' @export
#'
subset_h5_list_by_barcodes <- function(h5_list,
                                       barcodes,
                                       original_barcodes = FALSE) {

  assertthat::assert_that(class(h5_list) == "list")
  assertthat::assert_that("matrix" %in% names(h5_list))
  assertthat::assert_that("matrix_dgCMatrix" %in% names(h5_list))

  if(original_barcodes) {
    keep <- match(barcodes, h5_list$matrix$observations$original_barcodes)
  } else {
    keep <- match(barcodes, colnames(h5_list$matrix_dgCMatrix))
  }

  h5_list$matrix_dgCMatrix <- h5_list$matrix_dgCMatrix[, keep]

  if("observations" %in% names(h5_list$matrix)) {
    additional_cell_values <- names(h5_list$matrix$observations)

    for(additional_value in additional_cell_values) {
      h5_list$matrix$observations[[additional_value]] <- h5_list$matrix$observations[[additional_value]][keep]
    }
  }

  h5_list
}

#' Split a 10x HDF5 file based on HTOparser results
#'
#' @param h5_file a character object specifying the location of a 10x Genomics .h5 file.
#' @param hash_category_table a data.frame or data.table with results from HTOparser::categorize_binary_hash_matrix() consisting of 3 columns: cell_barcode, hto_category, and hto_barcode.
#' @param hash_count_matrix (optional) a matrix or dgCMatrix with results from CITE-seq-Count, HTOparser::add_missing_hto_rows(), or HTOparser::barcode_table_to_matrix().
#'
#' @return A list object with contents of the input h5_file separated by each hto_barcode. Also includes multiplets.
#' @export
#'
split_h5_list_by_hash <- function(h5_list,
                                  hash_category_table,
                                  hash_count_matrix = NULL,
                                  add_uuid = TRUE,
                                  add_name = TRUE,
                                  well_id = NULL) {

  assertthat::assert_that(class(h5_list) == "list")

  assertthat::assert_that(sum(class(hash_category_table) %in% c("data.frame","data.table")) > 0)

  if(!is.null(hash_count_matrix)) {
    assertthat::assert_that(class(hash_count_matrix) %in% c("dgCMatrix","matrix"))
  }

  assertthat::assert_that(is.logical(add_uuid))
  assertthat::assert_that(is.logical(add_name))

  if(add_uuid) {
    h5_list <- add_cell_ids(h5_list,
                            add_uuid = TRUE,
                            replace_barcode = TRUE,
                            retain_original_barcode = TRUE,
                            add_name = FALSE)

    h5_list$matrix$observations$original_barcodes <- sub("-.+","",h5_list$matrix$observations$original_barcodes)
    common_barcodes <- intersect(h5_list$matrix$observations$original_barcodes, hash_category_table$cell_barcode)

  } else {
    h5_list$matrix$barcodes <- sub("-.+","",h5_list$matrix$barcodes)
    common_barcodes <- intersect(h5_list$matrix$barcodes, hash_category_table$cell_barcode)
  }

  if(add_name) {
    h5_list <- add_cell_ids(h5_list,
                            add_uuid = FALSE,
                            add_name = TRUE)
  }

  if(!is.null(well_id)) {
    assertthat::assert_that(is.character(well_id))
    assertthat::assert_that(length(well_id) == 1)

    h5_list$matrix$observations$well_id <- rep(well_id, length(h5_list$matrix$barcodes))
  }

  common_hash_table <- hash_category_table[hash_category_table$cell_barcode %in% common_barcodes,]

  singlet_hash_table <- common_hash_table[common_hash_table$hto_category == "singlet",]
  multiplet_hash_table <- common_hash_table[common_hash_table$hto_category != "singlet",]

  hto_barcodes <- unique(as.character(singlet_hash_table$hto_barcode))

  h5_list <- h5_list_convert_to_dgCMatrix(h5_list)

  split_h5_list <- list()
  for(barcode in hto_barcodes) {
    hto_hash_table <- singlet_hash_table[singlet_hash_table$hto_barcode == barcode,]

    split_h5_list[[barcode]] <- subset_h5_list_by_barcodes(h5_list,
                                                           hto_hash_table$cell_barcode,
                                                           original_barcodes = TRUE)

    split_h5_list[[barcode]] <- h5_list_convert_from_dgCMatrix(split_h5_list[[barcode]])

    if(!is.null(hash_count_matrix)) {
      hto_hash_matrix <- hash_count_matrix[, hto_hash_table$cell_barcode]
      hto_hash_matrix <- as(hto_hash_matrix, "dgCMatrix")

      if(add_uuid) {
        colnames(hto_hash_matrix) <- split_h5_list[[barcode]]$matrix$barcode[match(colnames(hto_hash_matrix),
                                                                                   split_h5_list[[barcode]]$matrix$observations$original_barcode)]
      }

      split_h5_list[[barcode]] <- h5_list_add_dgCMatrix(split_h5_list[[barcode]],
                                                        mat = hto_hash_matrix,
                                                        target = "hash_count_matrix")
    }

  }

  split_h5_list$multiplet <- subset_h5_list_by_barcodes(h5_list,
                                                        multiplet_hash_table$cell_barcode,
                                                        original_barcodes = TRUE)
  split_h5_list$multiplet <- h5_list_convert_from_dgCMatrix(split_h5_list$multiplet)
  if(!is.null(hash_count_matrix)) {
    multiplet_hash_matrix <- hash_count_matrix[, multiplet_hash_table$cell_barcode]
    multiplet_hash_matrix <- as(multiplet_hash_matrix, "dgCMatrix")

    if(add_uuid) {
      colnames(multiplet_hash_matrix) <- split_h5_list$multiplet$matrix$observations$barcode[match(colnames(multiplet_hash_matrix),
                                                                                                   split_h5_list$multiplet$matrix$observations$original_barcode)]
    }


    split_h5_list$multiplet <- h5_list_add_dgCMatrix(split_h5_list$multiplet,
                                                     mat = multiplet_hash_matrix,
                                                     target = "hash_count_matrix")
  }

  split_h5_list
}

#' Concatenate two h5_list objects.
#'
#' This is suitable for h5_list objects that contain vectors and/or dgCMatrices. It expects that the two lists have the same structure and names.
#'
#' @param x the first list to combine.
#' @param y the second list to append.
#'
#' @return a list object with the same structure as x.
#' @export
#'
cat_h5_list <- function (x, y) {

  assertthat::assert_that(is.list(x))
  assertthat::assert_that(is.list(y))
  assertthat::assert_that(all(names(x) == names(y)))

  for (v in seq_along(x)) {

    if(class(x[[v]]) == "list") {
      # If the target is a list, recurse to the next level
      x[[v]] <- cat_h5_list(x[[v]], y[[v]])
    } else if(class(x[[v]]) == "dgCMatrix") {
      # If it's a dgCMatrix, perform a cbind
      x[[v]] <- cbind(x[[v]], y[[v]])
    } else {
      # If it's a vector, use c to combine.
      x[[v]] <- c(as.vector(x[[v]]), as.vector(y[[v]]))
    }
  }
  x
}

#' Reduce a list-of-lists of h5_list objects to a single, concatenated object.
#'
#' @param h5_ll A list-of-lists containing h5_list objects generated by rhdf5::h5dump() or similar.
#' @param sparse_matrices A vector of object names within each list that should be treated as dgCMatrices for combining. Default is "matrix", which is used by 10x.
#'
#' @return An h5_list object with the structure of a single h5_list within the h5_ll object.
#' @export
#'
reduce_h5_list <- function(h5_ll,
                           sparse_matrices = c("matrix")) {

  assertthat::assert_that(is.list(h5_ll))
  assertthat::assert_that(all(sparse_matrices %in% names(h5_ll[[1]])))

  for(i in seq_along(sparse_matrices)) {
    h5_ll <- lapply(h5_ll,
                    h5_list_convert_to_dgCMatrix,
                    sparse_matrices[i])
  }

  out_list <- h5_ll[[1]]
  for(i in 2:length(h5_ll)) {
    out_list <- cat_h5_list(out_list, h5_ll[[i]])
  }

  for(i in seq_along(sparse_matrices)) {
    # Exception here for "features", which shouldn't be concatenated.
    out_list[[sparse_matrices[i]]]$features <- h5_ll[[1]][[sparse_matrices[i]]]$features

    out_list <- h5_list_convert_from_dgCMatrix(out_list,
                                               target = sparse_matrices[i])
  }

  out_list

}
